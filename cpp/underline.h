#pragma once
#include <functional>

#ifdef QT_CORE_LIB
#include <QtCore>
#include <QList>
#include <QStringList>
#include <QVariantList>
#include <QVariantMap>
#include <QObject>
#endif

#ifdef QT_QUICK_LIB
#include <QJSValue>
#include <QJSValueIterator>
#endif

namespace _ {

    namespace Private {

        /// Source: https://stackoverflow.com/questions/5052211/changing-value-type-of-a-given-stl-container
        template <class Container, class NewType>
        struct rebind {
        };

#ifdef QT_CORE_LIB
        template <class NewType>
        struct rebind<QStringList, NewType> {
            typedef QList<NewType> type;
        };

        template <class NewType>
        struct rebind<QVariantList, NewType> {
            typedef QList<NewType> type;
        };
#endif

        template <class ValueType, class... Args, template <class...> class Container, class NewType>
        struct rebind<Container<ValueType, Args...>, NewType>
        {
            typedef Container<NewType, typename rebind<Args, NewType>::type...> type;
        };

        template <typename T>
        struct container_value_type {
            typedef typename std::remove_reference<T>::type::value_type type;
        };

        /// Check is the Functor be able to take Args as input. It works with generic lambda.
        template <typename Functor,typename ...Args>
        struct is_args_compatible {
            enum {
                value = std::is_convertible<Functor, std::function<void(Args...)> >::value
            };
        };

        template <typename Type, typename Functor, typename ...Args>
        using enable_if_args_compatible = typename std::enable_if<is_args_compatible<Functor, Args &&...>::value, Type>;

        template <typename Type, typename Functor, typename ...Args>
        using enable_if_args_not_compatible = typename std::enable_if<!is_args_compatible<Functor, Args &&...>::value, Type>;

        /// Convert to a function with zero paramter. Only the return type remained the same.
        template <typename Functor>
        typename enable_if_args_compatible<decltype(std::declval<Functor>()()), Functor>::type
        decl_func0();

        template <typename Functor>
        typename enable_if_args_not_compatible<void, Functor>::type
        decl_func0();

        template <typename Functor, typename Arg1>
        typename enable_if_args_compatible<decltype(std::declval<Functor>()(std::declval<Arg1>())), Functor, Arg1>::type
        decl_func0();

        template <typename Functor, typename Arg1>
        typename enable_if_args_not_compatible<void, Functor, Arg1>::type
        decl_func0();

        template <typename Functor, typename Arg1, typename Arg2>
        typename enable_if_args_compatible<decltype(std::declval<Functor>()(std::declval<Arg1>(), std::declval<Arg2>())), Functor, Arg1, Arg2>::type
        decl_func0();

        template <typename Functor, typename Arg1, typename Arg2>
        typename enable_if_args_not_compatible<void, Functor, Arg1, Arg2>::type
        decl_func0();

        template <typename Functor, typename Arg1, typename Arg2, typename Arg3>
        typename enable_if_args_compatible<decltype(std::declval<Functor>()(std::declval<Arg1>(), std::declval<Arg2>(), std::declval<Arg3>())), Functor, Arg1, Arg2, Arg3>::type
        decl_func0();

        template <typename Functor, typename Arg1, typename Arg2, typename Arg3>
        typename enable_if_args_not_compatible<void, Functor, Arg1, Arg2, Arg3>::type
        decl_func0();

        template <typename Functor, typename ...Args>
        struct ret_func {
            using type = decltype(decl_func0<Functor, Args&&...>());
        };

        /* Generated by code-generator */
        template <typename Functor>
        inline auto invoke(Functor functor) ->
        typename std::enable_if<is_args_compatible<Functor>::value,
        typename ret_func<Functor>::type>::type {
            return functor();
        }

        template <typename Functor>
        struct is_invokable0 {
            enum {
               value = is_args_compatible<Functor>::value
            };
        };

        template <typename Functor, typename Arg1>
        inline auto invoke(Functor functor, Arg1) ->
        typename std::enable_if<is_args_compatible<Functor>::value,
        typename ret_func<Functor>::type>::type {
            return functor();
        }

        template <typename Functor, typename Arg1>
        inline auto invoke(Functor functor, Arg1 arg1) ->
        typename std::enable_if<is_args_compatible<Functor, Arg1>::value,
        typename ret_func<Functor, Arg1>::type>::type {
            return functor(arg1);
        }

        template <typename Functor, typename Arg1>
        struct is_invokable1 {
            enum {
               value = is_args_compatible<Functor>::value || is_args_compatible<Functor, Arg1>::value
            };
        };

        template <typename Functor, typename Arg1, typename Arg2>
        inline auto invoke(Functor functor, Arg1, Arg2) ->
        typename std::enable_if<is_args_compatible<Functor>::value,
        typename ret_func<Functor>::type>::type {
            return functor();
        }

        template <typename Functor, typename Arg1, typename Arg2>
        inline auto invoke(Functor functor, Arg1 arg1, Arg2) ->
        typename std::enable_if<is_args_compatible<Functor, Arg1>::value,
        typename ret_func<Functor, Arg1>::type>::type {
            return functor(arg1);
        }

        template <typename Functor, typename Arg1, typename Arg2>
        inline auto invoke(Functor functor, Arg1 arg1, Arg2 arg2) ->
        typename std::enable_if<is_args_compatible<Functor, Arg1, Arg2>::value,
        typename ret_func<Functor, Arg1, Arg2>::type>::type {
            return functor(arg1, arg2);
        }

        template <typename Functor, typename Arg1, typename Arg2>
        struct is_invokable2 {
            enum {
               value = is_args_compatible<Functor>::value || is_args_compatible<Functor, Arg1>::value || is_args_compatible<Functor, Arg1, Arg2>::value
            };
        };

        template <typename Functor, typename Arg1, typename Arg2, typename Arg3>
        inline auto invoke(Functor functor, Arg1, Arg2, Arg3) ->
        typename std::enable_if<is_args_compatible<Functor>::value,
        typename ret_func<Functor>::type>::type {
            return functor();
        }

        template <typename Functor, typename Arg1, typename Arg2, typename Arg3>
        inline auto invoke(Functor functor, Arg1 arg1, Arg2, Arg3) ->
        typename std::enable_if<is_args_compatible<Functor, Arg1>::value,
        typename ret_func<Functor, Arg1>::type>::type {
            return functor(arg1);
        }

        template <typename Functor, typename Arg1, typename Arg2, typename Arg3>
        inline auto invoke(Functor functor, Arg1 arg1, Arg2 arg2, Arg3) ->
        typename std::enable_if<is_args_compatible<Functor, Arg1, Arg2>::value,
        typename ret_func<Functor, Arg1, Arg2>::type>::type {
            return functor(arg1, arg2);
        }

        template <typename Functor, typename Arg1, typename Arg2, typename Arg3>
        inline auto invoke(Functor functor, Arg1 arg1, Arg2 arg2, Arg3 arg3) ->
        typename std::enable_if<is_args_compatible<Functor, Arg1, Arg2, Arg3>::value,
        typename ret_func<Functor, Arg1, Arg2, Arg3>::type>::type {
            return functor(arg1, arg2, arg3);
        }

        template <typename Functor, typename Arg1, typename Arg2, typename Arg3>
        struct is_invokable3 {
            enum {
               value = is_args_compatible<Functor>::value || is_args_compatible<Functor, Arg1>::value || is_args_compatible<Functor, Arg1, Arg2>::value || is_args_compatible<Functor, Arg1, Arg2, Arg3>::value
            };
        };

        /* End of code-generator */

        /// Declare a function with same output as invoke but taking zero argument.

        template <typename Functor>
        inline decltype(invoke<Functor>(std::declval<Functor>())) decl_invoke0();

        template <typename Functor, typename Arg1>
        inline decltype(invoke<Functor>(std::declval<Functor>(), std::declval<Arg1>())) decl_invoke0();

        template <typename Functor, typename Arg1, typename Arg2>
        inline decltype(invoke<Functor>(std::declval<Functor>(), std::declval<Arg1>(), std::declval<Arg2>())) decl_invoke0();

        template <typename Functor, typename Arg1, typename Arg2, typename Arg3>
        inline decltype(invoke<Functor>(std::declval<Functor>(), std::declval<Arg1>(), std::declval<Arg2>(), std::declval<Arg3>())) decl_invoke0();

        template <typename Functor, typename ...Args>
        struct ret_invoke {
            using type = decltype(decl_invoke0<Functor, Args&&...>());
        };

        ///Value is a wrapper of any data structure include <void>.
        template <typename T>
        class Value {
        public:
            template <typename Functor, typename ...Args>
            inline void invoke(Functor functor, Args... args) {
                value = _::Private::invoke(functor, args...);
            }

            template <typename Other>
            inline bool canConvert() {
                return std::is_convertible<T, Other>::value;
            }

            template <typename Any>
            inline typename std::enable_if<std::is_convertible<Any, T>::value, bool>::type
            equals(Any&& other) {
                return (T) other == value;
            }

            template <typename Any>
            inline typename std::enable_if<!std::is_convertible<Any, T>::value, bool>::type
            equals(Any&& other) {
                (void) other;
                return false;
            }

            T value;
        };

        template <>
        class Value<void> {
        public:
            template <typename Functor, typename ...Args>
            inline void invoke(Functor functor, Args... args) {
                _::Private::invoke(functor, args...);
            }

            template <typename Other>
            inline bool canConvert() {
                return false;
            }

            template <typename Any>
            inline bool equals(Any && any) {
                (void) any;
                return false;
            }
        };

#ifdef QT_CORE_LIB
        inline QVariant _get(const QVariantMap& object, const QStringList &path, const QVariant& defaultValue) ;

        inline QVariant _get(const QObject* object, const QStringList &path, const QVariant& defaultValue) {

            QString key = path[0];

            const QMetaObject* meta = object->metaObject();

            if (meta->indexOfProperty(key.toUtf8().constData()) < 0) {
                return defaultValue;
            }

            QVariant value = object->property(key.toUtf8().constData());

            if (path.size() == 1) {
                return value;
            }

            QStringList nextPath = path;
            nextPath.removeFirst();

            if (value.canConvert<QObject*>()) {
                return _get(qvariant_cast<QObject*>(value), nextPath, defaultValue);
            } else if (value.type() == QVariant::Map) {
                return _get(value.toMap(), nextPath, defaultValue);
            } else {
                return defaultValue;
            }
        }

        inline QVariant _get(const QVariantMap& object, const QStringList &path, const QVariant& defaultValue) {

            QString key = path[0];

            if (!object.contains(key)) {
                return defaultValue;
            }

            QVariant value = object[key];

            if (path.size() == 1) {
                return value;
            }

            QStringList nextPath = path;
            nextPath.removeFirst();

            if (value.canConvert<QObject*>()) {
                return _get(qvariant_cast<QObject*>(value), nextPath, defaultValue);
            } else if (value.type() == QVariant::Map) {
                return _get(value.toMap(), nextPath, defaultValue);
            } else {
                return defaultValue;
            }
        }
#endif
    } /* End of Private Session */

    template <typename Map, typename Functor>
    inline void forIn(const Map& object, Functor iteratee) {
        auto iter = object.begin();
        while (iter != object.end()) {

            Private::Value<typename Private::ret_invoke<Functor, typename std::remove_reference<Map>::type::mapped_type, typename std::remove_reference<Map>::type::key_type, Map>::type> value;
            value.invoke(iteratee, iter.value(), iter.key(), object);

            if (value.template canConvert<bool>() && value.equals(false)) {
                break;
            }
            iter++;
        }
    }

#ifdef QT_CORE_LIB
    /*
     If a property contains QObject pointer, it will be converted to QVariantMap.

     In case you need to obtain a QObject pointer, please use get().
     */

    /// Assign properties from source object to the destination object.
    inline void assign(QVariantMap &dest, const QObject *source)
    {
        const QMetaObject* meta = source->metaObject();

        for (int i = 0 ; i < meta->propertyCount(); i++) {
            const QMetaProperty property = meta->property(i);
            QString p = property.name();

            QVariant value = source->property(property.name());

            if (value.canConvert<QObject*>()) {
                QVariantMap map;
                assign(map, value.value<QObject*>()); // nested properties is not supported yet
                value = map;
            }

            dest[p] = value;
        }

    }

    inline void assign(QObject *dest, const QVariantMap & source)
    {
        const QMetaObject* meta = dest->metaObject();

        QMap<QString,QVariant>::const_iterator iter = source.begin();
        while (iter != source.end()) {
            QByteArray key = iter.key().toLocal8Bit();

            int index = meta->indexOfProperty(key.constData());
            if (index < 0) {
                qWarning() << QString("_::assign: assigns an non-existed property: %1").arg(iter.key());
                iter++;
                continue;
            }

            QVariant orig = dest->property(key.constData());
            QVariant value = source[iter.key()];

            if (orig.canConvert<QObject*>()) {
                if (value.type() != QVariant::Map) {
                    qWarning() << QString("assign:expect a QVariantMap property but it is not: %1");
                } else {
                    assign(orig.value<QObject*>(), value.toMap());
                }

            } else if (orig != value) {
                dest->setProperty(key.constData(), value);
            }

            iter++;
        }
    }

    inline void assign(QVariantMap& dest, const QVariantMap& source) {
        QMap<QString,QVariant>::const_iterator iter = source.begin();
        while (iter != source.end()) {
            dest[iter.key()] = iter.value();
            iter++;
        }
    }

    inline void assign(QObject* dest, const QObject* source) {
        const QMetaObject* sourceMeta = source->metaObject();

        for (int i = 0 ; i < sourceMeta->propertyCount(); i++) {
            const QMetaProperty property = sourceMeta->property(i);
            QString p = property.name();

            QVariant value = source->property(property.name());
            dest->setProperty(p.toLocal8Bit().constData(), value);
        }
    }
#endif

#ifdef QT_QUICK_LIB
    inline void assign(QObject *dest, const QJSValue &source)
    {
        if (dest == 0) {
            return;
        }

        const QMetaObject* meta = dest->metaObject();
        QJSValueIterator iter(source);

        while (iter.hasNext()) {
            iter.next();
            QByteArray key = iter.name().toLocal8Bit();
            int index = meta->indexOfProperty(key.constData());
            if (index < 0) {
                qWarning() << QString("QSyncable::assign:assign a non-existed property: %1").arg(iter.name());
                continue;
            }

            QVariant orig = dest->property(key.constData());

            if (orig.canConvert<QObject*>()) {
                if (!iter.value().isObject()) {
                    qWarning() << QString("QSyncable::assign:expect a object property but it is not: %1");
                } else {
                    assign(orig.value<QObject*>(), iter.value());
                }
                continue;
            }

            QVariant value = iter.value().toVariant();
            if (orig != value) {
                dest->setProperty(key.constData(), value);
            }
        }
    }
#endif

    template <typename Dest, typename Source, typename... Args>
    inline auto assign(Dest& dest, const Source& source, Args... sources) -> typename std::enable_if< (sizeof...(Args) > 0), void>::type {
        assign(dest, source);
        assign(dest, sources...);
    }

    /* End of assign() */

#ifdef QT_CORE_LIB
    inline QVariant get(const QObject *object, const QStringList &path, const QVariant& defaultValue)
    {
        return Private::_get(object, path, defaultValue);
    }

    inline QVariant get(const QObject *object, const QString &path, const QVariant& defaultValue = QVariant())
    {
        return get(object, path.split("."), defaultValue);
    }

    inline QVariant get(const QVariantMap &source, const QStringList &path, const QVariant &defaultValue = QVariant())
    {
        return Private::_get(source, path, defaultValue);
    }

    inline QVariant get(const QVariantMap &source, const QString &path, const QVariant &defaultValue = QVariant())
    {
        return get(source, path.split("."), defaultValue);
    }

    inline void set(QVariantMap &data, const QStringList &path, const QVariant &value)
    {
        QString key = path[0];

        if (path.size() == 1) {
            data[key] = value;
        } else {
            if (!data.contains(key) || !data[key].canConvert<QVariantMap>()) {
                data[key] = QVariantMap();
            }
            QStringList nextPath = path;
            nextPath.removeFirst();
            QVariantMap map = data[key].toMap();
            set(map, nextPath, value);
            data[key] = map;
        }
    }

    inline void set(QVariantMap &data, const QString &path, const QVariant &value)
    {
        return set(data, path.split("."), value);
    }
    /// Creates an QVariantMap composed of the picked object properties at paths.
    /*
     Example:

         pick(object, QStringList() << "a" << "b.c");

     If a property contains QObject pointer, it will be converted to QVariantMap.

     In case you need to obtain a QObject pointer, please use get().

     */

    inline QVariantMap pick(QObject *object, const QStringList &paths)
    {
        QVariantMap data;
        foreach (QString path, paths) {
            QVariant value = get(object, path);
            if (value.isNull()) {
                continue;
            }

            if (value.canConvert<QObject*>()) {
                QVariantMap map;
                assign(map, value.value<QObject*>());
                value = map;
            }

            set(data, path, value);
        }
        return data;
    }


    inline QVariantMap pick(QVariantMap source, const QStringList &paths)
    {
        QVariantMap data;
        foreach (QString path, paths) {
            QVariant value = get(source, path);
            if (value.isNull()) {
                continue;
            }

            if (value.canConvert<QObject*>()) {
                QVariantMap map;
                assign(map, value.value<QObject*>());
                value = map;
            }

            set(data, path, value);
        }
        return data;
    }

    inline QVariantMap pick(QVariantMap source, const QVariantMap &paths)
    {
        return pick(source, paths.keys());
    }

    /// The opposite of pick(), this method creates an QVariantMap composed of the own properties that are not omitted.

    inline QVariantMap omit(const QVariantMap &source, const QVariantMap &properties)
    {

        QMap<QString,QVariant>::const_iterator iter = source.begin();
        QVariantMap result;

        while (iter != source.end()) {

            if (properties.contains(iter.key())) {
                iter++;
                continue;
            }

            QVariant value = source[iter.key()];

            if (value.canConvert<QObject*>()) {
                QVariantMap map;
                assign(map, value.value<QObject*>());
                value = map;
            }

            result[iter.key()] = value;
            iter++;
        }

        return result;
    }
#endif

    template <typename T, typename P>
    inline bool some(const T& list, P predicate) {
        bool res = false;

        for (unsigned int i = 0 ; i < (unsigned int) list.size() ; i++) {
            if (Private::invoke(predicate, list[i], i)) {
                res = true;
                break;
            }
        }
        return res;
    }

    template <typename T, typename F>
    inline auto map(const T& collection, F iteratee) -> typename Private::rebind<T,
        typename Private::ret_invoke<F, typename Private::container_value_type<T>::type, int, T>::type
    >::type {

        typename Private::rebind<T, typename Private::ret_invoke<F, typename Private::container_value_type<T>::type, int, T>::type>::type res;

        for (unsigned int i = 0 ; i < (unsigned int) collection.size() ; i++) {
            res.push_back(Private::invoke(iteratee, collection[i], i, collection));
        }

        return res;
    }

    template <typename T>
    T clamp(T number, T lower, T upper) {
        if (number > upper) {
            number = upper;
        }
        if (lower > number) {
            number = lower;
        }
        return number;
    }

    /// Sets the value at path of object. If a portion of path doesn't exist, it's created.
    /*
     Example:

     set(data, "a.b", 3); // data["a"] will be a QVariantMap that contains a key of "b".

     */


}
